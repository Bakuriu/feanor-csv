from itertools import cycle

from .arbitrary import Arbitrary


class IntArbitrary(Arbitrary):
    def __init__(self, random_funcs, config=None):
        super().__init__(random_funcs, 'int', config)

    def __call__(self):
        return self._random_funcs.randint(self.config.lowerbound, self.config.upperbound)

    @classmethod
    def default_config(cls):
        return {'lowerbound': 0, 'upperbound': 1000000}


class MultiArbitrary(Arbitrary):
    def __init__(self, random_funcs, arbitraries, config=None):
        super().__init__(random_funcs, 'multi', config)
        self._arbitraries = tuple(arbitraries)

    @property
    def number_of_columns(self):
        return len(self._arbitraries)

    def __call__(self):
        return tuple(arbitrary() for arbitrary in self._arbitraries)

    def __getitem__(self, item):
        return self._arbitraries[item]


class RepeaterArbitrary(Arbitrary):
    """An arbitrary that returns for `num_repeats` time the value generated by
    the wrapped arbitrary.

    """

    def __init__(self, random_funcs, arbitrary, config=None):
        super().__init__(random_funcs, 'repeater', config)
        self._arbitrary = arbitrary
        self._current_count = 0
        self._sentinel = object()
        self._last_value = self._sentinel

    def __call__(self):
        if self._last_value is self._sentinel or self._current_count >= self.config.num_repeats:
            self._last_value = self._arbitrary()
            self._current_count = 1
        else:
            self._current_count += 1

        return self._last_value


class FixedArbitrary(Arbitrary):
    def __init__(self, random_funcs, config):
        super().__init__(random_funcs, 'fixed', config)

    def __call__(self):
        return self.config.value


class CyclingArbitrary(Arbitrary):
    def __init__(self, random_funcs, config):
        super().__init__(random_funcs, 'fixed', config)
        self._values = cycle(self.config.values)

    def __call__(self):
        return next(self._values)
